import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from '@/hooks/use-toast';

export interface OrderItem {
  id: string;
  order_id: string;
  product_name: string;
  sku: string | null;
  quantity: number;
  unit: string;
  unit_price: number;
  total_price: number;
  notes: string | null;
  created_at: string;
}

export interface ClientOrder {
  id: string;
  user_id: string;
  client_id: string;
  order_number: string;
  status: 'pending' | 'confirmed' | 'in_production' | 'ready' | 'dispatched' | 'delivered' | 'cancelled';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  order_date: string;
  expected_delivery: string | null;
  actual_delivery: string | null;
  subtotal: number;
  tax_amount: number;
  discount_amount: number;
  total_amount: number;
  paid_amount: number;
  payment_status: 'unpaid' | 'partial' | 'paid';
  notes: string | null;
  created_at: string;
  updated_at: string;
  items?: OrderItem[];
  client?: {
    id: string;
    name: string;
    company: string | null;
    email: string | null;
    phone: string | null;
  };
}

export interface CreateOrderInput {
  client_id: string;
  status?: 'pending' | 'confirmed' | 'in_production' | 'ready' | 'dispatched' | 'delivered' | 'cancelled';
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  expected_delivery?: string;
  subtotal: number;
  tax_amount?: number;
  discount_amount?: number;
  total_amount: number;
  notes?: string;
  items: CreateOrderItemInput[];
}

export interface CreateOrderItemInput {
  product_name: string;
  sku?: string;
  quantity: number;
  unit?: string;
  unit_price: number;
  total_price: number;
  notes?: string;
}

export function useClientOrders() {
  const { user } = useAuth();
  const [orders, setOrders] = useState<ClientOrder[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchOrders = async () => {
    if (!user) {
      setOrders([]);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('client_orders')
        .select(`
          *,
          client:clients(id, name, company, email, phone),
          items:order_items(*)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setOrders(data as ClientOrder[]);
      setError(null);
    } catch (err: any) {
      console.error('Error fetching orders:', err);
      setError(err.message);
      toast({
        title: "Error loading orders",
        description: err.message,
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const createOrder = async (input: CreateOrderInput): Promise<ClientOrder | null> => {
    if (!user) {
      toast({
        title: "Authentication required",
        description: "Please login to create orders",
        variant: "destructive"
      });
      return null;
    }

    try {
      // Create order first
      const { data: orderData, error: orderError } = await supabase
        .from('client_orders')
        .insert({
          user_id: user.id,
          client_id: input.client_id,
          order_number: '', // Will be auto-generated by trigger
          status: input.status || 'pending',
          priority: input.priority || 'normal',
          expected_delivery: input.expected_delivery,
          subtotal: input.subtotal,
          tax_amount: input.tax_amount || 0,
          discount_amount: input.discount_amount || 0,
          total_amount: input.total_amount,
          notes: input.notes
        })
        .select()
        .single();

      if (orderError) throw orderError;

      // Create order items
      if (input.items && input.items.length > 0) {
        const itemsWithOrderId = input.items.map(item => ({
          ...item,
          order_id: orderData.id
        }));

        const { error: itemsError } = await supabase
          .from('order_items')
          .insert(itemsWithOrderId);

      if (itemsError) throw itemsError;
      }

      // Update client's total orders count
      const { data: clientData } = await supabase
        .from('clients')
        .select('total_orders')
        .eq('id', input.client_id)
        .single();
      
      if (clientData) {
        await supabase
          .from('clients')
          .update({ total_orders: (clientData.total_orders || 0) + 1 })
          .eq('id', input.client_id);
      }

      await fetchOrders(); // Refresh to get full data with joins

      toast({
        title: "Order created",
        description: `Order ${orderData.order_number} has been created`
      });
      
      return orderData as ClientOrder;
    } catch (err: any) {
      console.error('Error creating order:', err);
      toast({
        title: "Error creating order",
        description: err.message,
        variant: "destructive"
      });
      return null;
    }
  };

  const updateOrderStatus = async (
    id: string, 
    status: ClientOrder['status']
  ): Promise<boolean> => {
    try {
      const updates: any = { status };
      
      // If delivered, set actual delivery date
      if (status === 'delivered') {
        updates.actual_delivery = new Date().toISOString().split('T')[0];
      }

      const { error } = await supabase
        .from('client_orders')
        .update(updates)
        .eq('id', id);

      if (error) throw error;

      setOrders(prev => prev.map(o => 
        o.id === id ? { ...o, ...updates, updated_at: new Date().toISOString() } : o
      ));

      toast({
        title: "Order updated",
        description: `Order status changed to ${status}`
      });
      return true;
    } catch (err: any) {
      console.error('Error updating order:', err);
      toast({
        title: "Error updating order",
        description: err.message,
        variant: "destructive"
      });
      return false;
    }
  };

  const updatePaymentStatus = async (
    id: string,
    payment_status: ClientOrder['payment_status'],
    paid_amount?: number
  ): Promise<boolean> => {
    try {
      const updates: any = { payment_status };
      if (paid_amount !== undefined) {
        updates.paid_amount = paid_amount;
      }

      const { error } = await supabase
        .from('client_orders')
        .update(updates)
        .eq('id', id);

      if (error) throw error;

      setOrders(prev => prev.map(o => 
        o.id === id ? { ...o, ...updates, updated_at: new Date().toISOString() } : o
      ));

      toast({
        title: "Payment updated",
        description: `Payment status changed to ${payment_status}`
      });
      return true;
    } catch (err: any) {
      console.error('Error updating payment:', err);
      toast({
        title: "Error updating payment",
        description: err.message,
        variant: "destructive"
      });
      return false;
    }
  };

  const deleteOrder = async (id: string): Promise<boolean> => {
    try {
      const { error } = await supabase
        .from('client_orders')
        .delete()
        .eq('id', id);

      if (error) throw error;

      setOrders(prev => prev.filter(o => o.id !== id));
      toast({
        title: "Order deleted",
        description: "Order has been removed"
      });
      return true;
    } catch (err: any) {
      console.error('Error deleting order:', err);
      toast({
        title: "Error deleting order",
        description: err.message,
        variant: "destructive"
      });
      return false;
    }
  };

  const getOrderById = (id: string): ClientOrder | undefined => {
    return orders.find(o => o.id === id);
  };

  const getOrdersByClientId = (clientId: string): ClientOrder[] => {
    return orders.filter(o => o.client_id === clientId);
  };

  useEffect(() => {
    fetchOrders();
  }, [user]);

  // Stats calculations
  const stats = {
    total: orders.length,
    pending: orders.filter(o => o.status === 'pending').length,
    confirmed: orders.filter(o => o.status === 'confirmed').length,
    inProduction: orders.filter(o => o.status === 'in_production').length,
    ready: orders.filter(o => o.status === 'ready').length,
    dispatched: orders.filter(o => o.status === 'dispatched').length,
    delivered: orders.filter(o => o.status === 'delivered').length,
    cancelled: orders.filter(o => o.status === 'cancelled').length,
    totalValue: orders.reduce((sum, o) => sum + (o.total_amount || 0), 0),
    totalPaid: orders.reduce((sum, o) => sum + (o.paid_amount || 0), 0),
    totalPending: orders.reduce((sum, o) => sum + ((o.total_amount || 0) - (o.paid_amount || 0)), 0),
    urgent: orders.filter(o => o.priority === 'urgent' || o.priority === 'high').length
  };

  return {
    orders,
    loading,
    error,
    stats,
    fetchOrders,
    createOrder,
    updateOrderStatus,
    updatePaymentStatus,
    deleteOrder,
    getOrderById,
    getOrdersByClientId
  };
}
